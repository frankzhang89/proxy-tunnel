#!/bin/bash

# =====================================================
# NIO Tunnel Startup Script for Linux/macOS
# =====================================================
# Usage: ./nio-tunnel [start|stop|restart|status]
# Double-click in file manager to start (default action)
# =====================================================

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Configuration - JAR is in the same directory as this script
APP_NAME="nio-tunnel"
JAR_FILE="$SCRIPT_DIR/nio-tunnel.jar"
PID_FILE="$SCRIPT_DIR/nio-tunnel.pid"
CONFIG_FILE="$SCRIPT_DIR/config.properties"
LOG_FILE="$SCRIPT_DIR/nio-tunnel.log"
JAVA_OPTS="-Xms64m -Xmx256m"

# Colors for output (only when running in terminal)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# -----------------------------------------------------
# Helper Functions
# -----------------------------------------------------

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_ok() {
    echo -e "${GREEN}[OK]${NC} $1"
}

# Check if JAR exists
check_jar() {
    if [ ! -f "$JAR_FILE" ]; then
        log_error "JAR file not found: $JAR_FILE"
        echo "Please build the project first: mvn clean package"
        return 1
    fi
    return 0
}

# Get PID of running process
get_pid() {
    local pid=""
    
    # First try PID file
    if [ -f "$PID_FILE" ]; then
        pid=$(cat "$PID_FILE" 2>/dev/null)
        # Verify process is still running
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "$pid"
            return 0
        fi
    fi
    
    # Fallback: search for running process
    pid=$(pgrep -f "nio-tunnel.*\.jar" 2>/dev/null | head -1)
    if [ -n "$pid" ]; then
        echo "$pid" > "$PID_FILE"
        echo "$pid"
        return 0
    fi
    
    return 1
}

# Check if process is running
is_running() {
    get_pid > /dev/null 2>&1
    return $?
}

# -----------------------------------------------------
# Commands
# -----------------------------------------------------

do_start() {
    local silent_mode="$1"
    
    check_jar || return 1
    
    if is_running; then
        local pid=$(get_pid)
        if [ "$silent_mode" != "silent" ]; then
            log_warn "$APP_NAME is already running (PID: $pid)"
            echo "Use './nio-tunnel restart' to restart"
        fi
        return 1
    fi
    
    # Start in background
    nohup java $JAVA_OPTS -jar "$JAR_FILE" > "$LOG_FILE" 2>&1 &
    local new_pid=$!
    
    # Wait a moment for startup
    sleep 2
    
    # Check if started successfully
    if kill -0 "$new_pid" 2>/dev/null; then
        echo "$new_pid" > "$PID_FILE"
        
        # If silent mode (double-click), exit quietly
        if [ "$silent_mode" = "silent" ]; then
            return 0
        fi
        
        log_ok "$APP_NAME started successfully (PID: $new_pid)"
        echo ""
        echo -e "${BLUE}Listening on:${NC}"
        echo "  HTTP Proxy:   http://127.0.0.1:31281"
        echo "  SOCKS5 Proxy: socks5://127.0.0.1:31282"
        echo ""
        echo "Log file: $LOG_FILE"
    else
        log_error "Failed to start $APP_NAME"
        echo "Check log file: $LOG_FILE"
        return 1
    fi
}

do_stop() {
    log_info "Stopping $APP_NAME..."
    
    if ! is_running; then
        log_info "$APP_NAME is not running"
        [ -f "$PID_FILE" ] && rm -f "$PID_FILE"
        return 0
    fi
    
    local pid=$(get_pid)
    
    # Try graceful shutdown first
    kill "$pid" 2>/dev/null
    
    # Wait for process to stop
    local count=0
    while kill -0 "$pid" 2>/dev/null && [ $count -lt 10 ]; do
        sleep 1
        count=$((count + 1))
    done
    
    # Force kill if still running
    if kill -0 "$pid" 2>/dev/null; then
        log_warn "Process didn't stop gracefully, forcing..."
        kill -9 "$pid" 2>/dev/null
        sleep 1
    fi
    
    if ! kill -0 "$pid" 2>/dev/null; then
        log_ok "$APP_NAME stopped (PID: $pid)"
        [ -f "$PID_FILE" ] && rm -f "$PID_FILE"
    else
        log_error "Failed to stop $APP_NAME"
        return 1
    fi
}

do_restart() {
    log_info "Restarting $APP_NAME..."
    do_stop
    sleep 2
    do_start
}

do_status() {
    if is_running; then
        local pid=$(get_pid)
        echo -e "${GREEN}[RUNNING]${NC} $APP_NAME is running (PID: $pid)"
        
        # Show some process info
        if command -v ps > /dev/null; then
            echo ""
            ps -p "$pid" -o pid,user,%cpu,%mem,start,time,command 2>/dev/null | head -2
        fi
    else
        echo -e "${RED}[STOPPED]${NC} $APP_NAME is not running"
    fi
}

show_help() {
    echo ""
    echo "Usage: ./nio-tunnel [command]"
    echo ""
    echo "Commands:"
    echo "  start     Start the proxy tunnel (default)"
    echo "  stop      Stop the proxy tunnel"
    echo "  restart   Restart the proxy tunnel"
    echo "  status    Check if the proxy is running"
    echo "  help      Show this help message"
    echo ""
    echo "Double-click the script in file manager to start silently in background."
    echo ""
}

# -----------------------------------------------------
# Main
# -----------------------------------------------------

# Default action is 'start' (for double-click GUI usage)
ACTION="${1:-start}"

# Detect if running from GUI (no terminal) for silent mode
GUI_MODE=false
if [ ! -t 0 ] && [ ! -t 1 ]; then
    GUI_MODE=true
fi

case "$ACTION" in
    start)
        if [ "$GUI_MODE" = true ]; then
            # Silent start for GUI double-click
            do_start "silent"
        else
            do_start
        fi
        ;;
    stop)
        do_stop
        ;;
    restart)
        do_restart
        ;;
    status)
        do_status
        ;;
    help|-h|--help)
        show_help
        ;;
    *)
        log_error "Unknown action: $ACTION"
        show_help
        exit 1
        ;;
esac